Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> code
Rule 1     code -> code sent
Rule 2     code -> sent
Rule 3     code -> empty
Rule 4     sent -> statement
Rule 5     sent -> instruction SEMI
Rule 6     instruction -> assign
Rule 7     instruction -> function
Rule 8     statement -> function_definition
Rule 9     statement -> for_statement
Rule 10    statement -> if_statement
Rule 11    statement -> while_statement
Rule 12    for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
Rule 13    for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
Rule 14    for_valid_expr -> expr_num
Rule 15    for_valid_expr -> expr_arithm
Rule 16    for_valid_iter -> PLUS
Rule 17    for_valid_iter -> PLUSPLUS
Rule 18    for_valid_iter -> MINUS
Rule 19    for_valid_iter -> MINUSMINUS
Rule 20    if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE
Rule 21    if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
Rule 22    if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
Rule 23    if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
Rule 24    elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
Rule 25    elif_sent -> empty
Rule 26    while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
Rule 27    function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE
Rule 28    assign -> ID ASSIGN expr_type
Rule 29    assign -> ID ASSIGN expr_arithm
Rule 30    assign -> ID ASSIGN logic_list
Rule 31    assign -> ID ASSIGN expr_list
Rule 32    assign -> ID ASSIGN function
Rule 33    function -> ID LPAREN list RPAREN
Rule 34    list -> list COMMA ID
Rule 35    list -> list COMMA function
Rule 36    list -> function
Rule 37    list -> ID
Rule 38    list -> list COMMA expr_type
Rule 39    list -> expr_type
Rule 40    list -> empty
Rule 41    list -> list COMMA expr_arithm
Rule 42    list -> list COMMA logic_list
Rule 43    list -> expr_arithm
Rule 44    list -> logic_list
Rule 45    logic_list -> LPAREN logic_list RPAREN
Rule 46    logic_list -> logic_list AND logic_list
Rule 47    logic_list -> logic_list OR logic_list
Rule 48    logic_list -> expr_bool
Rule 49    expr_bool -> expr_bool EQ expr_bool
Rule 50    expr_bool -> expr_bool LT expr_bool
Rule 51    expr_bool -> expr_bool LET expr_bool
Rule 52    expr_bool -> expr_bool GT expr_bool
Rule 53    expr_bool -> expr_bool GET expr_bool
Rule 54    expr_bool -> expr_bool DIFF expr_bool
Rule 55    expr_bool -> NOT expr_bool
Rule 56    expr_bool -> function
Rule 57    expr_bool -> expr_type
Rule 58    expr_bool -> expr_arithm
Rule 59    expr_arithm -> LPAREN expr_arithm RPAREN
Rule 60    expr_arithm -> expr_arithm PLUS expr_arithm
Rule 61    expr_arithm -> expr_arithm MINUS expr_arithm
Rule 62    expr_arithm -> expr_arithm MULTIPLY expr_arithm
Rule 63    expr_arithm -> expr_arithm DIVIDE expr_arithm
Rule 64    expr_arithm -> MINUS expr_arithm
Rule 65    expr_arithm -> ID
Rule 66    expr_arithm -> function
Rule 67    expr_arithm -> expr_type
Rule 68    function -> sent_index_list
Rule 69    sent_index_list -> sent_index_list LBRACKET ID RBRACKET
Rule 70    sent_index_list -> ID LBRACKET ID RBRACKET
Rule 71    sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET
Rule 72    sent_index_list -> ID LBRACKET INTEGER RBRACKET
Rule 73    expr_list -> LBRACKET expr_inside_list RBRACKET
Rule 74    expr_inside_list -> expr_inside_list COMMA expr_type
Rule 75    expr_inside_list -> expr_inside_list COMMA expr_bool
Rule 76    expr_inside_list -> expr_type
Rule 77    expr_inside_list -> expr_bool
Rule 78    expr_inside_list -> empty
Rule 79    expr_type -> expr_num
Rule 80    expr_type -> expr_string
Rule 81    expr_bool -> TRUE
Rule 82    expr_bool -> FALSE
Rule 83    expr_num -> FLOAT
Rule 84    expr_num -> INTEGER
Rule 85    expr_string -> STRING
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 46
ASSIGN               : 28 29 30 31 32
COMMA                : 12 12 34 35 38 41 42 74 75
DEF                  : 27
DIFF                 : 54
DIVIDE               : 63
ELIF                 : 24
ELSE                 : 22 23
EQ                   : 49
FALSE                : 82
FLOAT                : 83
FOR                  : 12 13
GET                  : 53
GT                   : 52
ID                   : 13 13 27 28 29 30 31 32 33 34 37 65 69 70 70 72
IF                   : 20 21 22 23
IN                   : 13
INTEGER              : 71 72 84
LBRACE               : 12 13 20 21 22 22 23 23 24 26 27
LBRACKET             : 69 70 71 72 73
LET                  : 51
LPAREN               : 12 13 20 21 22 23 24 26 27 33 45 59
LT                   : 50
MINUS                : 18 61 64
MINUSMINUS           : 19
MULTIPLY             : 62
NOT                  : 55
OR                   : 47
PLUS                 : 16 60
PLUSPLUS             : 17
RBRACE               : 12 13 20 21 22 22 23 23 24 26 27
RBRACKET             : 69 70 71 72 73
RPAREN               : 12 13 20 21 22 23 24 26 27 33 45 59
SEMI                 : 5
STRING               : 85
TRUE                 : 81
WHILE                : 26
error                : 

Nonterminals, with rules where they appear

assign               : 6
code                 : 1 12 13 20 21 22 22 23 23 24 26 27 0
elif_sent            : 21 23 24
empty                : 3 25 40 78
expr_arithm          : 15 29 41 43 58 59 60 60 61 61 62 62 63 63 64
expr_bool            : 48 49 49 50 50 51 51 52 52 53 53 54 54 55 75 77
expr_inside_list     : 73 74 75
expr_list            : 31
expr_num             : 14 79
expr_string          : 80
expr_type            : 28 38 39 57 67 74 76
for_statement        : 9
for_valid_expr       : 12 12
for_valid_iter       : 12
function             : 7 32 35 36 56 66
function_definition  : 8
if_statement         : 10
instruction          : 5
list                 : 33 34 35 38 41 42
logic_list           : 20 21 22 23 24 26 30 42 44 45 46 46 47 47
sent                 : 1 2
sent_index_list      : 68 69 71
statement            : 4
while_statement      : 11

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 1
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 1

    (0) S' -> code .
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 2

    (2) code -> sent .

    DEF             reduce using rule 2 (code -> sent .)
    FOR             reduce using rule 2 (code -> sent .)
    IF              reduce using rule 2 (code -> sent .)
    WHILE           reduce using rule 2 (code -> sent .)
    ID              reduce using rule 2 (code -> sent .)
    $end            reduce using rule 2 (code -> sent .)
    RBRACE          reduce using rule 2 (code -> sent .)


state 3

    (3) code -> empty .

    DEF             reduce using rule 3 (code -> empty .)
    FOR             reduce using rule 3 (code -> empty .)
    IF              reduce using rule 3 (code -> empty .)
    WHILE           reduce using rule 3 (code -> empty .)
    ID              reduce using rule 3 (code -> empty .)
    $end            reduce using rule 3 (code -> empty .)
    RBRACE          reduce using rule 3 (code -> empty .)


state 4

    (4) sent -> statement .

    DEF             reduce using rule 4 (sent -> statement .)
    FOR             reduce using rule 4 (sent -> statement .)
    IF              reduce using rule 4 (sent -> statement .)
    WHILE           reduce using rule 4 (sent -> statement .)
    ID              reduce using rule 4 (sent -> statement .)
    $end            reduce using rule 4 (sent -> statement .)
    RBRACE          reduce using rule 4 (sent -> statement .)


state 5

    (5) sent -> instruction . SEMI

    SEMI            shift and go to state 19


state 6

    (8) statement -> function_definition .

    DEF             reduce using rule 8 (statement -> function_definition .)
    FOR             reduce using rule 8 (statement -> function_definition .)
    IF              reduce using rule 8 (statement -> function_definition .)
    WHILE           reduce using rule 8 (statement -> function_definition .)
    ID              reduce using rule 8 (statement -> function_definition .)
    $end            reduce using rule 8 (statement -> function_definition .)
    RBRACE          reduce using rule 8 (statement -> function_definition .)


state 7

    (9) statement -> for_statement .

    DEF             reduce using rule 9 (statement -> for_statement .)
    FOR             reduce using rule 9 (statement -> for_statement .)
    IF              reduce using rule 9 (statement -> for_statement .)
    WHILE           reduce using rule 9 (statement -> for_statement .)
    ID              reduce using rule 9 (statement -> for_statement .)
    $end            reduce using rule 9 (statement -> for_statement .)
    RBRACE          reduce using rule 9 (statement -> for_statement .)


state 8

    (10) statement -> if_statement .

    DEF             reduce using rule 10 (statement -> if_statement .)
    FOR             reduce using rule 10 (statement -> if_statement .)
    IF              reduce using rule 10 (statement -> if_statement .)
    WHILE           reduce using rule 10 (statement -> if_statement .)
    ID              reduce using rule 10 (statement -> if_statement .)
    $end            reduce using rule 10 (statement -> if_statement .)
    RBRACE          reduce using rule 10 (statement -> if_statement .)


state 9

    (11) statement -> while_statement .

    DEF             reduce using rule 11 (statement -> while_statement .)
    FOR             reduce using rule 11 (statement -> while_statement .)
    IF              reduce using rule 11 (statement -> while_statement .)
    WHILE           reduce using rule 11 (statement -> while_statement .)
    ID              reduce using rule 11 (statement -> while_statement .)
    $end            reduce using rule 11 (statement -> while_statement .)
    RBRACE          reduce using rule 11 (statement -> while_statement .)


state 10

    (6) instruction -> assign .

    SEMI            reduce using rule 6 (instruction -> assign .)


state 11

    (7) instruction -> function .

    SEMI            reduce using rule 7 (instruction -> function .)


state 12

    (27) function_definition -> DEF . ID LPAREN RPAREN LBRACE code RBRACE

    ID              shift and go to state 20


state 13

    (28) assign -> ID . ASSIGN expr_type
    (29) assign -> ID . ASSIGN expr_arithm
    (30) assign -> ID . ASSIGN logic_list
    (31) assign -> ID . ASSIGN expr_list
    (32) assign -> ID . ASSIGN function
    (33) function -> ID . LPAREN list RPAREN
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

    ASSIGN          shift and go to state 21
    LPAREN          shift and go to state 22
    LBRACKET        shift and go to state 23


state 14

    (12) for_statement -> FOR . LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> FOR . LPAREN ID IN ID RPAREN LBRACE code RBRACE

    LPAREN          shift and go to state 24


state 15

    (20) if_statement -> IF . LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> IF . LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> IF . LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF . LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE

    LPAREN          shift and go to state 25


state 16

    (26) while_statement -> WHILE . LPAREN logic_list RPAREN LBRACE code RBRACE

    LPAREN          shift and go to state 26


state 17

    (68) function -> sent_index_list .
    (69) sent_index_list -> sent_index_list . LBRACKET ID RBRACKET
    (71) sent_index_list -> sent_index_list . LBRACKET INTEGER RBRACKET

    SEMI            reduce using rule 68 (function -> sent_index_list .)
    PLUS            reduce using rule 68 (function -> sent_index_list .)
    MINUS           reduce using rule 68 (function -> sent_index_list .)
    MULTIPLY        reduce using rule 68 (function -> sent_index_list .)
    DIVIDE          reduce using rule 68 (function -> sent_index_list .)
    EQ              reduce using rule 68 (function -> sent_index_list .)
    LT              reduce using rule 68 (function -> sent_index_list .)
    LET             reduce using rule 68 (function -> sent_index_list .)
    GT              reduce using rule 68 (function -> sent_index_list .)
    GET             reduce using rule 68 (function -> sent_index_list .)
    DIFF            reduce using rule 68 (function -> sent_index_list .)
    AND             reduce using rule 68 (function -> sent_index_list .)
    OR              reduce using rule 68 (function -> sent_index_list .)
    RPAREN          reduce using rule 68 (function -> sent_index_list .)
    COMMA           reduce using rule 68 (function -> sent_index_list .)
    RBRACKET        reduce using rule 68 (function -> sent_index_list .)
    LBRACKET        shift and go to state 27


state 18

    (1) code -> code sent .

    DEF             reduce using rule 1 (code -> code sent .)
    FOR             reduce using rule 1 (code -> code sent .)
    IF              reduce using rule 1 (code -> code sent .)
    WHILE           reduce using rule 1 (code -> code sent .)
    ID              reduce using rule 1 (code -> code sent .)
    $end            reduce using rule 1 (code -> code sent .)
    RBRACE          reduce using rule 1 (code -> code sent .)


state 19

    (5) sent -> instruction SEMI .

    DEF             reduce using rule 5 (sent -> instruction SEMI .)
    FOR             reduce using rule 5 (sent -> instruction SEMI .)
    IF              reduce using rule 5 (sent -> instruction SEMI .)
    WHILE           reduce using rule 5 (sent -> instruction SEMI .)
    ID              reduce using rule 5 (sent -> instruction SEMI .)
    $end            reduce using rule 5 (sent -> instruction SEMI .)
    RBRACE          reduce using rule 5 (sent -> instruction SEMI .)


state 20

    (27) function_definition -> DEF ID . LPAREN RPAREN LBRACE code RBRACE

    LPAREN          shift and go to state 28


state 21

    (28) assign -> ID ASSIGN . expr_type
    (29) assign -> ID ASSIGN . expr_arithm
    (30) assign -> ID ASSIGN . logic_list
    (31) assign -> ID ASSIGN . expr_list
    (32) assign -> ID ASSIGN . function
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (73) expr_list -> . LBRACKET expr_inside_list RBRACKET
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    LPAREN          shift and go to state 37
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    LBRACKET        shift and go to state 40
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    expr_type                      shift and go to state 30
    expr_arithm                    shift and go to state 31
    logic_list                     shift and go to state 32
    expr_list                      shift and go to state 33
    function                       shift and go to state 34
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36
    expr_bool                      shift and go to state 39
    sent_index_list                shift and go to state 17

state 22

    (33) function -> ID LPAREN . list RPAREN
    (34) list -> . list COMMA ID
    (35) list -> . list COMMA function
    (36) list -> . function
    (37) list -> . ID
    (38) list -> . list COMMA expr_type
    (39) list -> . expr_type
    (40) list -> . empty
    (41) list -> . list COMMA expr_arithm
    (42) list -> . list COMMA logic_list
    (43) list -> . expr_arithm
    (44) list -> . logic_list
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (86) empty -> .
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE

    ID              shift and go to state 47
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    LPAREN          shift and go to state 37
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    list                           shift and go to state 48
    function                       shift and go to state 49
    expr_type                      shift and go to state 50
    empty                          shift and go to state 51
    expr_arithm                    shift and go to state 52
    logic_list                     shift and go to state 53
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36
    expr_bool                      shift and go to state 39

state 23

    (70) sent_index_list -> ID LBRACKET . ID RBRACKET
    (72) sent_index_list -> ID LBRACKET . INTEGER RBRACKET

    ID              shift and go to state 54
    INTEGER         shift and go to state 55


state 24

    (12) for_statement -> FOR LPAREN . for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> FOR LPAREN . ID IN ID RPAREN LBRACE code RBRACE
    (14) for_valid_expr -> . expr_num
    (15) for_valid_expr -> . expr_arithm
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (85) expr_string -> . STRING

    ID              shift and go to state 58
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    STRING          shift and go to state 43

    for_valid_expr                 shift and go to state 57
    expr_num                       shift and go to state 59
    expr_arithm                    shift and go to state 60
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_string                    shift and go to state 36

state 25

    (20) if_statement -> IF LPAREN . logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> IF LPAREN . logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> IF LPAREN . logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN . logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 64
    expr_bool                      shift and go to state 39
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 26

    (26) while_statement -> WHILE LPAREN . logic_list RPAREN LBRACE code RBRACE
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 69
    expr_bool                      shift and go to state 39
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 27

    (69) sent_index_list -> sent_index_list LBRACKET . ID RBRACKET
    (71) sent_index_list -> sent_index_list LBRACKET . INTEGER RBRACKET

    ID              shift and go to state 70
    INTEGER         shift and go to state 71


state 28

    (27) function_definition -> DEF ID LPAREN . RPAREN LBRACE code RBRACE

    RPAREN          shift and go to state 72


state 29

    (65) expr_arithm -> ID .
    (33) function -> ID . LPAREN list RPAREN
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

    PLUS            reduce using rule 65 (expr_arithm -> ID .)
    MINUS           reduce using rule 65 (expr_arithm -> ID .)
    MULTIPLY        reduce using rule 65 (expr_arithm -> ID .)
    DIVIDE          reduce using rule 65 (expr_arithm -> ID .)
    SEMI            reduce using rule 65 (expr_arithm -> ID .)
    EQ              reduce using rule 65 (expr_arithm -> ID .)
    LT              reduce using rule 65 (expr_arithm -> ID .)
    LET             reduce using rule 65 (expr_arithm -> ID .)
    GT              reduce using rule 65 (expr_arithm -> ID .)
    GET             reduce using rule 65 (expr_arithm -> ID .)
    DIFF            reduce using rule 65 (expr_arithm -> ID .)
    AND             reduce using rule 65 (expr_arithm -> ID .)
    OR              reduce using rule 65 (expr_arithm -> ID .)
    RPAREN          reduce using rule 65 (expr_arithm -> ID .)
    COMMA           reduce using rule 65 (expr_arithm -> ID .)
    RBRACKET        reduce using rule 65 (expr_arithm -> ID .)
    LPAREN          shift and go to state 22
    LBRACKET        shift and go to state 23


state 30

    (28) assign -> ID ASSIGN expr_type .
    (67) expr_arithm -> expr_type .
    (57) expr_bool -> expr_type .

  ! reduce/reduce conflict for SEMI resolved using rule 28 (assign -> ID ASSIGN expr_type .)
  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for AND resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for OR resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for SEMI resolved using rule 28 (assign -> ID ASSIGN expr_type .)
    SEMI            reduce using rule 28 (assign -> ID ASSIGN expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    AND             reduce using rule 57 (expr_bool -> expr_type .)
    OR              reduce using rule 57 (expr_bool -> expr_type .)

  ! SEMI            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! AND             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! OR              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! SEMI            [ reduce using rule 57 (expr_bool -> expr_type .) ]


state 31

    (29) assign -> ID ASSIGN expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm
    (58) expr_bool -> expr_arithm .

  ! reduce/reduce conflict for SEMI resolved using rule 29 (assign -> ID ASSIGN expr_arithm .)
    SEMI            reduce using rule 29 (assign -> ID ASSIGN expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    EQ              reduce using rule 58 (expr_bool -> expr_arithm .)
    LT              reduce using rule 58 (expr_bool -> expr_arithm .)
    LET             reduce using rule 58 (expr_bool -> expr_arithm .)
    GT              reduce using rule 58 (expr_bool -> expr_arithm .)
    GET             reduce using rule 58 (expr_bool -> expr_arithm .)
    DIFF            reduce using rule 58 (expr_bool -> expr_arithm .)
    AND             reduce using rule 58 (expr_bool -> expr_arithm .)
    OR              reduce using rule 58 (expr_bool -> expr_arithm .)

  ! SEMI            [ reduce using rule 58 (expr_bool -> expr_arithm .) ]


state 32

    (30) assign -> ID ASSIGN logic_list .
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    SEMI            reduce using rule 30 (assign -> ID ASSIGN logic_list .)
    AND             shift and go to state 77
    OR              shift and go to state 78


state 33

    (31) assign -> ID ASSIGN expr_list .

    SEMI            reduce using rule 31 (assign -> ID ASSIGN expr_list .)


state 34

    (32) assign -> ID ASSIGN function .
    (66) expr_arithm -> function .
    (56) expr_bool -> function .

  ! reduce/reduce conflict for SEMI resolved using rule 32 (assign -> ID ASSIGN function .)
  ! reduce/reduce conflict for EQ resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for DIFF resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for AND resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for OR resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for SEMI resolved using rule 32 (assign -> ID ASSIGN function .)
    SEMI            reduce using rule 32 (assign -> ID ASSIGN function .)
    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)
    EQ              reduce using rule 56 (expr_bool -> function .)
    LT              reduce using rule 56 (expr_bool -> function .)
    LET             reduce using rule 56 (expr_bool -> function .)
    GT              reduce using rule 56 (expr_bool -> function .)
    GET             reduce using rule 56 (expr_bool -> function .)
    DIFF            reduce using rule 56 (expr_bool -> function .)
    AND             reduce using rule 56 (expr_bool -> function .)
    OR              reduce using rule 56 (expr_bool -> function .)

  ! SEMI            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! EQ              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! DIFF            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! AND             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! OR              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! SEMI            [ reduce using rule 56 (expr_bool -> function .) ]


state 35

    (79) expr_type -> expr_num .

    SEMI            reduce using rule 79 (expr_type -> expr_num .)
    PLUS            reduce using rule 79 (expr_type -> expr_num .)
    MINUS           reduce using rule 79 (expr_type -> expr_num .)
    MULTIPLY        reduce using rule 79 (expr_type -> expr_num .)
    DIVIDE          reduce using rule 79 (expr_type -> expr_num .)
    EQ              reduce using rule 79 (expr_type -> expr_num .)
    LT              reduce using rule 79 (expr_type -> expr_num .)
    LET             reduce using rule 79 (expr_type -> expr_num .)
    GT              reduce using rule 79 (expr_type -> expr_num .)
    GET             reduce using rule 79 (expr_type -> expr_num .)
    DIFF            reduce using rule 79 (expr_type -> expr_num .)
    AND             reduce using rule 79 (expr_type -> expr_num .)
    OR              reduce using rule 79 (expr_type -> expr_num .)
    RPAREN          reduce using rule 79 (expr_type -> expr_num .)
    COMMA           reduce using rule 79 (expr_type -> expr_num .)
    RBRACKET        reduce using rule 79 (expr_type -> expr_num .)


state 36

    (80) expr_type -> expr_string .

    SEMI            reduce using rule 80 (expr_type -> expr_string .)
    PLUS            reduce using rule 80 (expr_type -> expr_string .)
    MINUS           reduce using rule 80 (expr_type -> expr_string .)
    MULTIPLY        reduce using rule 80 (expr_type -> expr_string .)
    DIVIDE          reduce using rule 80 (expr_type -> expr_string .)
    EQ              reduce using rule 80 (expr_type -> expr_string .)
    LT              reduce using rule 80 (expr_type -> expr_string .)
    LET             reduce using rule 80 (expr_type -> expr_string .)
    GT              reduce using rule 80 (expr_type -> expr_string .)
    GET             reduce using rule 80 (expr_type -> expr_string .)
    DIFF            reduce using rule 80 (expr_type -> expr_string .)
    AND             reduce using rule 80 (expr_type -> expr_string .)
    OR              reduce using rule 80 (expr_type -> expr_string .)
    RPAREN          reduce using rule 80 (expr_type -> expr_string .)
    COMMA           reduce using rule 80 (expr_type -> expr_string .)
    RBRACKET        reduce using rule 80 (expr_type -> expr_string .)


state 37

    (59) expr_arithm -> LPAREN . expr_arithm RPAREN
    (45) logic_list -> LPAREN . logic_list RPAREN
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 37
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 79
    logic_list                     shift and go to state 80
    function                       shift and go to state 81
    expr_type                      shift and go to state 82
    expr_bool                      shift and go to state 39
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 38

    (64) expr_arithm -> MINUS . expr_arithm
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 83
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 39

    (48) logic_list -> expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

    AND             reduce using rule 48 (logic_list -> expr_bool .)
    OR              reduce using rule 48 (logic_list -> expr_bool .)
    SEMI            reduce using rule 48 (logic_list -> expr_bool .)
    RPAREN          reduce using rule 48 (logic_list -> expr_bool .)
    COMMA           reduce using rule 48 (logic_list -> expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89


state 40

    (73) expr_list -> LBRACKET . expr_inside_list RBRACKET
    (74) expr_inside_list -> . expr_inside_list COMMA expr_type
    (75) expr_inside_list -> . expr_inside_list COMMA expr_bool
    (76) expr_inside_list -> . expr_type
    (77) expr_inside_list -> . expr_bool
    (78) expr_inside_list -> . empty
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (86) empty -> .
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    RBRACKET        reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38

    expr_inside_list               shift and go to state 90
    expr_type                      shift and go to state 91
    expr_bool                      shift and go to state 92
    empty                          shift and go to state 93
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36
    function                       shift and go to state 65
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17

state 41

    (83) expr_num -> FLOAT .

    SEMI            reduce using rule 83 (expr_num -> FLOAT .)
    PLUS            reduce using rule 83 (expr_num -> FLOAT .)
    MINUS           reduce using rule 83 (expr_num -> FLOAT .)
    MULTIPLY        reduce using rule 83 (expr_num -> FLOAT .)
    DIVIDE          reduce using rule 83 (expr_num -> FLOAT .)
    EQ              reduce using rule 83 (expr_num -> FLOAT .)
    LT              reduce using rule 83 (expr_num -> FLOAT .)
    LET             reduce using rule 83 (expr_num -> FLOAT .)
    GT              reduce using rule 83 (expr_num -> FLOAT .)
    GET             reduce using rule 83 (expr_num -> FLOAT .)
    DIFF            reduce using rule 83 (expr_num -> FLOAT .)
    AND             reduce using rule 83 (expr_num -> FLOAT .)
    OR              reduce using rule 83 (expr_num -> FLOAT .)
    RPAREN          reduce using rule 83 (expr_num -> FLOAT .)
    COMMA           reduce using rule 83 (expr_num -> FLOAT .)
    RBRACKET        reduce using rule 83 (expr_num -> FLOAT .)


state 42

    (84) expr_num -> INTEGER .

    SEMI            reduce using rule 84 (expr_num -> INTEGER .)
    PLUS            reduce using rule 84 (expr_num -> INTEGER .)
    MINUS           reduce using rule 84 (expr_num -> INTEGER .)
    MULTIPLY        reduce using rule 84 (expr_num -> INTEGER .)
    DIVIDE          reduce using rule 84 (expr_num -> INTEGER .)
    EQ              reduce using rule 84 (expr_num -> INTEGER .)
    LT              reduce using rule 84 (expr_num -> INTEGER .)
    LET             reduce using rule 84 (expr_num -> INTEGER .)
    GT              reduce using rule 84 (expr_num -> INTEGER .)
    GET             reduce using rule 84 (expr_num -> INTEGER .)
    DIFF            reduce using rule 84 (expr_num -> INTEGER .)
    AND             reduce using rule 84 (expr_num -> INTEGER .)
    OR              reduce using rule 84 (expr_num -> INTEGER .)
    RPAREN          reduce using rule 84 (expr_num -> INTEGER .)
    COMMA           reduce using rule 84 (expr_num -> INTEGER .)
    RBRACKET        reduce using rule 84 (expr_num -> INTEGER .)


state 43

    (85) expr_string -> STRING .

    SEMI            reduce using rule 85 (expr_string -> STRING .)
    PLUS            reduce using rule 85 (expr_string -> STRING .)
    MINUS           reduce using rule 85 (expr_string -> STRING .)
    MULTIPLY        reduce using rule 85 (expr_string -> STRING .)
    DIVIDE          reduce using rule 85 (expr_string -> STRING .)
    EQ              reduce using rule 85 (expr_string -> STRING .)
    LT              reduce using rule 85 (expr_string -> STRING .)
    LET             reduce using rule 85 (expr_string -> STRING .)
    GT              reduce using rule 85 (expr_string -> STRING .)
    GET             reduce using rule 85 (expr_string -> STRING .)
    DIFF            reduce using rule 85 (expr_string -> STRING .)
    AND             reduce using rule 85 (expr_string -> STRING .)
    OR              reduce using rule 85 (expr_string -> STRING .)
    RPAREN          reduce using rule 85 (expr_string -> STRING .)
    COMMA           reduce using rule 85 (expr_string -> STRING .)
    RBRACKET        reduce using rule 85 (expr_string -> STRING .)


state 44

    (55) expr_bool -> NOT . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 94
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 45

    (81) expr_bool -> TRUE .

    EQ              reduce using rule 81 (expr_bool -> TRUE .)
    LT              reduce using rule 81 (expr_bool -> TRUE .)
    LET             reduce using rule 81 (expr_bool -> TRUE .)
    GT              reduce using rule 81 (expr_bool -> TRUE .)
    GET             reduce using rule 81 (expr_bool -> TRUE .)
    DIFF            reduce using rule 81 (expr_bool -> TRUE .)
    AND             reduce using rule 81 (expr_bool -> TRUE .)
    OR              reduce using rule 81 (expr_bool -> TRUE .)
    SEMI            reduce using rule 81 (expr_bool -> TRUE .)
    RPAREN          reduce using rule 81 (expr_bool -> TRUE .)
    COMMA           reduce using rule 81 (expr_bool -> TRUE .)
    RBRACKET        reduce using rule 81 (expr_bool -> TRUE .)


state 46

    (82) expr_bool -> FALSE .

    EQ              reduce using rule 82 (expr_bool -> FALSE .)
    LT              reduce using rule 82 (expr_bool -> FALSE .)
    LET             reduce using rule 82 (expr_bool -> FALSE .)
    GT              reduce using rule 82 (expr_bool -> FALSE .)
    GET             reduce using rule 82 (expr_bool -> FALSE .)
    DIFF            reduce using rule 82 (expr_bool -> FALSE .)
    AND             reduce using rule 82 (expr_bool -> FALSE .)
    OR              reduce using rule 82 (expr_bool -> FALSE .)
    SEMI            reduce using rule 82 (expr_bool -> FALSE .)
    RPAREN          reduce using rule 82 (expr_bool -> FALSE .)
    COMMA           reduce using rule 82 (expr_bool -> FALSE .)
    RBRACKET        reduce using rule 82 (expr_bool -> FALSE .)


state 47

    (37) list -> ID .
    (33) function -> ID . LPAREN list RPAREN
    (65) expr_arithm -> ID .
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for RPAREN resolved using rule 37 (list -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (list -> ID .)
    RPAREN          reduce using rule 37 (list -> ID .)
    COMMA           reduce using rule 37 (list -> ID .)
    LPAREN          shift and go to state 22
    PLUS            reduce using rule 65 (expr_arithm -> ID .)
    MINUS           reduce using rule 65 (expr_arithm -> ID .)
    MULTIPLY        reduce using rule 65 (expr_arithm -> ID .)
    DIVIDE          reduce using rule 65 (expr_arithm -> ID .)
    EQ              reduce using rule 65 (expr_arithm -> ID .)
    LT              reduce using rule 65 (expr_arithm -> ID .)
    LET             reduce using rule 65 (expr_arithm -> ID .)
    GT              reduce using rule 65 (expr_arithm -> ID .)
    GET             reduce using rule 65 (expr_arithm -> ID .)
    DIFF            reduce using rule 65 (expr_arithm -> ID .)
    AND             reduce using rule 65 (expr_arithm -> ID .)
    OR              reduce using rule 65 (expr_arithm -> ID .)
    LBRACKET        shift and go to state 23

  ! RPAREN          [ reduce using rule 65 (expr_arithm -> ID .) ]
  ! COMMA           [ reduce using rule 65 (expr_arithm -> ID .) ]


state 48

    (33) function -> ID LPAREN list . RPAREN
    (34) list -> list . COMMA ID
    (35) list -> list . COMMA function
    (38) list -> list . COMMA expr_type
    (41) list -> list . COMMA expr_arithm
    (42) list -> list . COMMA logic_list

    RPAREN          shift and go to state 95
    COMMA           shift and go to state 96


state 49

    (36) list -> function .
    (66) expr_arithm -> function .
    (56) expr_bool -> function .

  ! reduce/reduce conflict for RPAREN resolved using rule 36 (list -> function .)
  ! reduce/reduce conflict for COMMA resolved using rule 36 (list -> function .)
  ! reduce/reduce conflict for EQ resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for DIFF resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for AND resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for OR resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for RPAREN resolved using rule 36 (list -> function .)
  ! reduce/reduce conflict for COMMA resolved using rule 36 (list -> function .)
    RPAREN          reduce using rule 36 (list -> function .)
    COMMA           reduce using rule 36 (list -> function .)
    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)
    EQ              reduce using rule 56 (expr_bool -> function .)
    LT              reduce using rule 56 (expr_bool -> function .)
    LET             reduce using rule 56 (expr_bool -> function .)
    GT              reduce using rule 56 (expr_bool -> function .)
    GET             reduce using rule 56 (expr_bool -> function .)
    DIFF            reduce using rule 56 (expr_bool -> function .)
    AND             reduce using rule 56 (expr_bool -> function .)
    OR              reduce using rule 56 (expr_bool -> function .)

  ! RPAREN          [ reduce using rule 66 (expr_arithm -> function .) ]
  ! COMMA           [ reduce using rule 66 (expr_arithm -> function .) ]
  ! EQ              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! DIFF            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! AND             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! OR              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! RPAREN          [ reduce using rule 56 (expr_bool -> function .) ]
  ! COMMA           [ reduce using rule 56 (expr_bool -> function .) ]


state 50

    (39) list -> expr_type .
    (67) expr_arithm -> expr_type .
    (57) expr_bool -> expr_type .

  ! reduce/reduce conflict for RPAREN resolved using rule 39 (list -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 39 (list -> expr_type .)
  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for AND resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for OR resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (list -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 39 (list -> expr_type .)
    RPAREN          reduce using rule 39 (list -> expr_type .)
    COMMA           reduce using rule 39 (list -> expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    AND             reduce using rule 57 (expr_bool -> expr_type .)
    OR              reduce using rule 57 (expr_bool -> expr_type .)

  ! RPAREN          [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! COMMA           [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! AND             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! OR              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RPAREN          [ reduce using rule 57 (expr_bool -> expr_type .) ]
  ! COMMA           [ reduce using rule 57 (expr_bool -> expr_type .) ]


state 51

    (40) list -> empty .

    RPAREN          reduce using rule 40 (list -> empty .)
    COMMA           reduce using rule 40 (list -> empty .)


state 52

    (43) list -> expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm
    (58) expr_bool -> expr_arithm .

  ! reduce/reduce conflict for RPAREN resolved using rule 43 (list -> expr_arithm .)
  ! reduce/reduce conflict for COMMA resolved using rule 43 (list -> expr_arithm .)
    RPAREN          reduce using rule 43 (list -> expr_arithm .)
    COMMA           reduce using rule 43 (list -> expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    EQ              reduce using rule 58 (expr_bool -> expr_arithm .)
    LT              reduce using rule 58 (expr_bool -> expr_arithm .)
    LET             reduce using rule 58 (expr_bool -> expr_arithm .)
    GT              reduce using rule 58 (expr_bool -> expr_arithm .)
    GET             reduce using rule 58 (expr_bool -> expr_arithm .)
    DIFF            reduce using rule 58 (expr_bool -> expr_arithm .)
    AND             reduce using rule 58 (expr_bool -> expr_arithm .)
    OR              reduce using rule 58 (expr_bool -> expr_arithm .)

  ! RPAREN          [ reduce using rule 58 (expr_bool -> expr_arithm .) ]
  ! COMMA           [ reduce using rule 58 (expr_bool -> expr_arithm .) ]


state 53

    (44) list -> logic_list .
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          reduce using rule 44 (list -> logic_list .)
    COMMA           reduce using rule 44 (list -> logic_list .)
    AND             shift and go to state 77
    OR              shift and go to state 78


state 54

    (70) sent_index_list -> ID LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 97


state 55

    (72) sent_index_list -> ID LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 98


state 56

    (59) expr_arithm -> LPAREN . expr_arithm RPAREN
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 99
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 57

    (12) for_statement -> FOR LPAREN for_valid_expr . COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE

    COMMA           shift and go to state 100


state 58

    (13) for_statement -> FOR LPAREN ID . IN ID RPAREN LBRACE code RBRACE
    (65) expr_arithm -> ID .
    (33) function -> ID . LPAREN list RPAREN
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

    IN              shift and go to state 101
    PLUS            reduce using rule 65 (expr_arithm -> ID .)
    MINUS           reduce using rule 65 (expr_arithm -> ID .)
    MULTIPLY        reduce using rule 65 (expr_arithm -> ID .)
    DIVIDE          reduce using rule 65 (expr_arithm -> ID .)
    COMMA           reduce using rule 65 (expr_arithm -> ID .)
    LPAREN          shift and go to state 22
    LBRACKET        shift and go to state 23


state 59

    (14) for_valid_expr -> expr_num .
    (79) expr_type -> expr_num .

  ! reduce/reduce conflict for COMMA resolved using rule 14 (for_valid_expr -> expr_num .)
    COMMA           reduce using rule 14 (for_valid_expr -> expr_num .)
    PLUS            reduce using rule 79 (expr_type -> expr_num .)
    MINUS           reduce using rule 79 (expr_type -> expr_num .)
    MULTIPLY        reduce using rule 79 (expr_type -> expr_num .)
    DIVIDE          reduce using rule 79 (expr_type -> expr_num .)

  ! COMMA           [ reduce using rule 79 (expr_type -> expr_num .) ]


state 60

    (15) for_valid_expr -> expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

    COMMA           reduce using rule 15 (for_valid_expr -> expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76


state 61

    (66) expr_arithm -> function .

    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)
    COMMA           reduce using rule 66 (expr_arithm -> function .)
    SEMI            reduce using rule 66 (expr_arithm -> function .)
    EQ              reduce using rule 66 (expr_arithm -> function .)
    LT              reduce using rule 66 (expr_arithm -> function .)
    LET             reduce using rule 66 (expr_arithm -> function .)
    GT              reduce using rule 66 (expr_arithm -> function .)
    GET             reduce using rule 66 (expr_arithm -> function .)
    DIFF            reduce using rule 66 (expr_arithm -> function .)
    AND             reduce using rule 66 (expr_arithm -> function .)
    OR              reduce using rule 66 (expr_arithm -> function .)
    RPAREN          reduce using rule 66 (expr_arithm -> function .)
    RBRACKET        reduce using rule 66 (expr_arithm -> function .)


state 62

    (67) expr_arithm -> expr_type .

    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)
    COMMA           reduce using rule 67 (expr_arithm -> expr_type .)
    SEMI            reduce using rule 67 (expr_arithm -> expr_type .)
    EQ              reduce using rule 67 (expr_arithm -> expr_type .)
    LT              reduce using rule 67 (expr_arithm -> expr_type .)
    LET             reduce using rule 67 (expr_arithm -> expr_type .)
    GT              reduce using rule 67 (expr_arithm -> expr_type .)
    GET             reduce using rule 67 (expr_arithm -> expr_type .)
    DIFF            reduce using rule 67 (expr_arithm -> expr_type .)
    AND             reduce using rule 67 (expr_arithm -> expr_type .)
    OR              reduce using rule 67 (expr_arithm -> expr_type .)
    RPAREN          reduce using rule 67 (expr_arithm -> expr_type .)
    RBRACKET        reduce using rule 67 (expr_arithm -> expr_type .)


state 63

    (45) logic_list -> LPAREN . logic_list RPAREN
    (59) expr_arithm -> LPAREN . expr_arithm RPAREN
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 80
    expr_arithm                    shift and go to state 79
    expr_bool                      shift and go to state 39
    function                       shift and go to state 81
    expr_type                      shift and go to state 82
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 64

    (20) if_statement -> IF LPAREN logic_list . RPAREN LBRACE code RBRACE
    (21) if_statement -> IF LPAREN logic_list . RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> IF LPAREN logic_list . RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN logic_list . RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          shift and go to state 102
    AND             shift and go to state 77
    OR              shift and go to state 78


state 65

    (56) expr_bool -> function .
    (66) expr_arithm -> function .

  ! reduce/reduce conflict for EQ resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for DIFF resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for RPAREN resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for AND resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for OR resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for COMMA resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for SEMI resolved using rule 56 (expr_bool -> function .)
    EQ              reduce using rule 56 (expr_bool -> function .)
    LT              reduce using rule 56 (expr_bool -> function .)
    LET             reduce using rule 56 (expr_bool -> function .)
    GT              reduce using rule 56 (expr_bool -> function .)
    GET             reduce using rule 56 (expr_bool -> function .)
    DIFF            reduce using rule 56 (expr_bool -> function .)
    RPAREN          reduce using rule 56 (expr_bool -> function .)
    AND             reduce using rule 56 (expr_bool -> function .)
    OR              reduce using rule 56 (expr_bool -> function .)
    RBRACKET        reduce using rule 56 (expr_bool -> function .)
    COMMA           reduce using rule 56 (expr_bool -> function .)
    SEMI            reduce using rule 56 (expr_bool -> function .)
    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)

  ! EQ              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! DIFF            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! RPAREN          [ reduce using rule 66 (expr_arithm -> function .) ]
  ! AND             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! OR              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! RBRACKET        [ reduce using rule 66 (expr_arithm -> function .) ]
  ! COMMA           [ reduce using rule 66 (expr_arithm -> function .) ]
  ! SEMI            [ reduce using rule 66 (expr_arithm -> function .) ]


state 66

    (57) expr_bool -> expr_type .
    (67) expr_arithm -> expr_type .

  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for AND resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for OR resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for SEMI resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 57 (expr_bool -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    RPAREN          reduce using rule 57 (expr_bool -> expr_type .)
    AND             reduce using rule 57 (expr_bool -> expr_type .)
    OR              reduce using rule 57 (expr_bool -> expr_type .)
    SEMI            reduce using rule 57 (expr_bool -> expr_type .)
    COMMA           reduce using rule 57 (expr_bool -> expr_type .)
    RBRACKET        reduce using rule 57 (expr_bool -> expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)

  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RPAREN          [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! AND             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! OR              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! SEMI            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! COMMA           [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RBRACKET        [ reduce using rule 67 (expr_arithm -> expr_type .) ]


state 67

    (58) expr_bool -> expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

    EQ              reduce using rule 58 (expr_bool -> expr_arithm .)
    LT              reduce using rule 58 (expr_bool -> expr_arithm .)
    LET             reduce using rule 58 (expr_bool -> expr_arithm .)
    GT              reduce using rule 58 (expr_bool -> expr_arithm .)
    GET             reduce using rule 58 (expr_bool -> expr_arithm .)
    DIFF            reduce using rule 58 (expr_bool -> expr_arithm .)
    RPAREN          reduce using rule 58 (expr_bool -> expr_arithm .)
    AND             reduce using rule 58 (expr_bool -> expr_arithm .)
    OR              reduce using rule 58 (expr_bool -> expr_arithm .)
    RBRACKET        reduce using rule 58 (expr_bool -> expr_arithm .)
    COMMA           reduce using rule 58 (expr_bool -> expr_arithm .)
    SEMI            reduce using rule 58 (expr_bool -> expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76


state 68

    (33) function -> ID . LPAREN list RPAREN
    (65) expr_arithm -> ID .
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

    LPAREN          shift and go to state 22
    PLUS            reduce using rule 65 (expr_arithm -> ID .)
    MINUS           reduce using rule 65 (expr_arithm -> ID .)
    MULTIPLY        reduce using rule 65 (expr_arithm -> ID .)
    DIVIDE          reduce using rule 65 (expr_arithm -> ID .)
    EQ              reduce using rule 65 (expr_arithm -> ID .)
    LT              reduce using rule 65 (expr_arithm -> ID .)
    LET             reduce using rule 65 (expr_arithm -> ID .)
    GT              reduce using rule 65 (expr_arithm -> ID .)
    GET             reduce using rule 65 (expr_arithm -> ID .)
    DIFF            reduce using rule 65 (expr_arithm -> ID .)
    RPAREN          reduce using rule 65 (expr_arithm -> ID .)
    AND             reduce using rule 65 (expr_arithm -> ID .)
    OR              reduce using rule 65 (expr_arithm -> ID .)
    RBRACKET        reduce using rule 65 (expr_arithm -> ID .)
    COMMA           reduce using rule 65 (expr_arithm -> ID .)
    SEMI            reduce using rule 65 (expr_arithm -> ID .)
    LBRACKET        shift and go to state 23


state 69

    (26) while_statement -> WHILE LPAREN logic_list . RPAREN LBRACE code RBRACE
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          shift and go to state 103
    AND             shift and go to state 77
    OR              shift and go to state 78


state 70

    (69) sent_index_list -> sent_index_list LBRACKET ID . RBRACKET

    RBRACKET        shift and go to state 104


state 71

    (71) sent_index_list -> sent_index_list LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 105


state 72

    (27) function_definition -> DEF ID LPAREN RPAREN . LBRACE code RBRACE

    LBRACE          shift and go to state 106


state 73

    (60) expr_arithm -> expr_arithm PLUS . expr_arithm
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 107
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 74

    (61) expr_arithm -> expr_arithm MINUS . expr_arithm
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 108
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 75

    (62) expr_arithm -> expr_arithm MULTIPLY . expr_arithm
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 109
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 76

    (63) expr_arithm -> expr_arithm DIVIDE . expr_arithm
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_arithm                    shift and go to state 110
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 77

    (46) logic_list -> logic_list AND . logic_list
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 111
    expr_bool                      shift and go to state 39
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 78

    (47) logic_list -> logic_list OR . logic_list
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 112
    expr_bool                      shift and go to state 39
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 79

    (59) expr_arithm -> LPAREN expr_arithm . RPAREN
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm
    (58) expr_bool -> expr_arithm .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 113
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    EQ              reduce using rule 58 (expr_bool -> expr_arithm .)
    LT              reduce using rule 58 (expr_bool -> expr_arithm .)
    LET             reduce using rule 58 (expr_bool -> expr_arithm .)
    GT              reduce using rule 58 (expr_bool -> expr_arithm .)
    GET             reduce using rule 58 (expr_bool -> expr_arithm .)
    DIFF            reduce using rule 58 (expr_bool -> expr_arithm .)
    AND             reduce using rule 58 (expr_bool -> expr_arithm .)
    OR              reduce using rule 58 (expr_bool -> expr_arithm .)

  ! RPAREN          [ reduce using rule 58 (expr_bool -> expr_arithm .) ]


state 80

    (45) logic_list -> LPAREN logic_list . RPAREN
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          shift and go to state 114
    AND             shift and go to state 77
    OR              shift and go to state 78


state 81

    (66) expr_arithm -> function .
    (56) expr_bool -> function .

  ! reduce/reduce conflict for EQ resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for DIFF resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for RPAREN resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for AND resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for OR resolved using rule 56 (expr_bool -> function .)
    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)
    EQ              reduce using rule 56 (expr_bool -> function .)
    LT              reduce using rule 56 (expr_bool -> function .)
    LET             reduce using rule 56 (expr_bool -> function .)
    GT              reduce using rule 56 (expr_bool -> function .)
    GET             reduce using rule 56 (expr_bool -> function .)
    DIFF            reduce using rule 56 (expr_bool -> function .)
    RPAREN          reduce using rule 56 (expr_bool -> function .)
    AND             reduce using rule 56 (expr_bool -> function .)
    OR              reduce using rule 56 (expr_bool -> function .)

  ! RPAREN          [ reduce using rule 66 (expr_arithm -> function .) ]
  ! EQ              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! DIFF            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! AND             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! OR              [ reduce using rule 66 (expr_arithm -> function .) ]


state 82

    (67) expr_arithm -> expr_type .
    (57) expr_bool -> expr_type .

  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for AND resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for OR resolved using rule 57 (expr_bool -> expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    RPAREN          reduce using rule 57 (expr_bool -> expr_type .)
    AND             reduce using rule 57 (expr_bool -> expr_type .)
    OR              reduce using rule 57 (expr_bool -> expr_type .)

  ! RPAREN          [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! AND             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! OR              [ reduce using rule 67 (expr_arithm -> expr_type .) ]


state 83

    (64) expr_arithm -> MINUS expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMI            reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    EQ              reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    LT              reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    LET             reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    GT              reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    GET             reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    DIFF            reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    AND             reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    OR              reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    RPAREN          reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    COMMA           reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    RBRACKET        reduce using rule 64 (expr_arithm -> MINUS expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76

  ! PLUS            [ reduce using rule 64 (expr_arithm -> MINUS expr_arithm .) ]
  ! MINUS           [ reduce using rule 64 (expr_arithm -> MINUS expr_arithm .) ]
  ! MULTIPLY        [ reduce using rule 64 (expr_arithm -> MINUS expr_arithm .) ]
  ! DIVIDE          [ reduce using rule 64 (expr_arithm -> MINUS expr_arithm .) ]


state 84

    (49) expr_bool -> expr_bool EQ . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 115
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 85

    (50) expr_bool -> expr_bool LT . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 116
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 86

    (51) expr_bool -> expr_bool LET . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 117
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 87

    (52) expr_bool -> expr_bool GT . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 118
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 88

    (53) expr_bool -> expr_bool GET . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 119
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 89

    (54) expr_bool -> expr_bool DIFF . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    expr_bool                      shift and go to state 120
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 90

    (73) expr_list -> LBRACKET expr_inside_list . RBRACKET
    (74) expr_inside_list -> expr_inside_list . COMMA expr_type
    (75) expr_inside_list -> expr_inside_list . COMMA expr_bool

    RBRACKET        shift and go to state 121
    COMMA           shift and go to state 122


state 91

    (76) expr_inside_list -> expr_type .
    (57) expr_bool -> expr_type .
    (67) expr_arithm -> expr_type .

  ! reduce/reduce conflict for RBRACKET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (expr_bool -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    RBRACKET        reduce using rule 57 (expr_bool -> expr_type .)
    COMMA           reduce using rule 57 (expr_bool -> expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)

  ! RBRACKET        [ reduce using rule 76 (expr_inside_list -> expr_type .) ]
  ! COMMA           [ reduce using rule 76 (expr_inside_list -> expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RBRACKET        [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! COMMA           [ reduce using rule 67 (expr_arithm -> expr_type .) ]


state 92

    (77) expr_inside_list -> expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

    RBRACKET        reduce using rule 77 (expr_inside_list -> expr_bool .)
    COMMA           reduce using rule 77 (expr_inside_list -> expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89


state 93

    (78) expr_inside_list -> empty .

    RBRACKET        reduce using rule 78 (expr_inside_list -> empty .)
    COMMA           reduce using rule 78 (expr_inside_list -> empty .)


state 94

    (55) expr_bool -> NOT expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 55 (expr_bool -> NOT expr_bool .)
    OR              reduce using rule 55 (expr_bool -> NOT expr_bool .)
    SEMI            reduce using rule 55 (expr_bool -> NOT expr_bool .)
    RPAREN          reduce using rule 55 (expr_bool -> NOT expr_bool .)
    COMMA           reduce using rule 55 (expr_bool -> NOT expr_bool .)
    RBRACKET        reduce using rule 55 (expr_bool -> NOT expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]
  ! LT              [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]
  ! LET             [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]
  ! GT              [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]
  ! GET             [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]
  ! DIFF            [ reduce using rule 55 (expr_bool -> NOT expr_bool .) ]


state 95

    (33) function -> ID LPAREN list RPAREN .

    SEMI            reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    PLUS            reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    MINUS           reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    MULTIPLY        reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    DIVIDE          reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    EQ              reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    LT              reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    LET             reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    GT              reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    GET             reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    DIFF            reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    AND             reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    OR              reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    RPAREN          reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    COMMA           reduce using rule 33 (function -> ID LPAREN list RPAREN .)
    RBRACKET        reduce using rule 33 (function -> ID LPAREN list RPAREN .)


state 96

    (34) list -> list COMMA . ID
    (35) list -> list COMMA . function
    (38) list -> list COMMA . expr_type
    (41) list -> list COMMA . expr_arithm
    (42) list -> list COMMA . logic_list
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE

    ID              shift and go to state 123
    LPAREN          shift and go to state 37
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46

    function                       shift and go to state 124
    expr_type                      shift and go to state 125
    expr_arithm                    shift and go to state 126
    logic_list                     shift and go to state 127
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36
    expr_bool                      shift and go to state 39

state 97

    (70) sent_index_list -> ID LBRACKET ID RBRACKET .

    LBRACKET        reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    SEMI            reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    PLUS            reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    MINUS           reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    MULTIPLY        reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    DIVIDE          reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    EQ              reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    LT              reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    LET             reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    GT              reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    GET             reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    DIFF            reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    AND             reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    OR              reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    RPAREN          reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    COMMA           reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)
    RBRACKET        reduce using rule 70 (sent_index_list -> ID LBRACKET ID RBRACKET .)


state 98

    (72) sent_index_list -> ID LBRACKET INTEGER RBRACKET .

    LBRACKET        reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    SEMI            reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    MULTIPLY        reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    LET             reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    GET             reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    DIFF            reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    RPAREN          reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)
    RBRACKET        reduce using rule 72 (sent_index_list -> ID LBRACKET INTEGER RBRACKET .)


state 99

    (59) expr_arithm -> LPAREN expr_arithm . RPAREN
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

    RPAREN          shift and go to state 113
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76


state 100

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA . for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (14) for_valid_expr -> . expr_num
    (15) for_valid_expr -> . expr_arithm
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (85) expr_string -> . STRING

    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38
    ID              shift and go to state 29
    STRING          shift and go to state 43

    for_valid_expr                 shift and go to state 128
    expr_num                       shift and go to state 59
    expr_arithm                    shift and go to state 60
    function                       shift and go to state 61
    expr_type                      shift and go to state 62
    sent_index_list                shift and go to state 17
    expr_string                    shift and go to state 36

state 101

    (13) for_statement -> FOR LPAREN ID IN . ID RPAREN LBRACE code RBRACE

    ID              shift and go to state 129


state 102

    (20) if_statement -> IF LPAREN logic_list RPAREN . LBRACE code RBRACE
    (21) if_statement -> IF LPAREN logic_list RPAREN . LBRACE code RBRACE elif_sent
    (22) if_statement -> IF LPAREN logic_list RPAREN . LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN logic_list RPAREN . LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE

    LBRACE          shift and go to state 130


state 103

    (26) while_statement -> WHILE LPAREN logic_list RPAREN . LBRACE code RBRACE

    LBRACE          shift and go to state 131


state 104

    (69) sent_index_list -> sent_index_list LBRACKET ID RBRACKET .

    LBRACKET        reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    SEMI            reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    PLUS            reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    MINUS           reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    MULTIPLY        reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    DIVIDE          reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    EQ              reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    LT              reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    LET             reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    GT              reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    GET             reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    DIFF            reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    AND             reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    OR              reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    RPAREN          reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    COMMA           reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)
    RBRACKET        reduce using rule 69 (sent_index_list -> sent_index_list LBRACKET ID RBRACKET .)


state 105

    (71) sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .

    LBRACKET        reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    SEMI            reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    MULTIPLY        reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    LET             reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    GET             reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    DIFF            reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    RPAREN          reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)
    RBRACKET        reduce using rule 71 (sent_index_list -> sent_index_list LBRACKET INTEGER RBRACKET .)


state 106

    (27) function_definition -> DEF ID LPAREN RPAREN LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 132
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 107

    (60) expr_arithm -> expr_arithm PLUS expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMI            reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    EQ              reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    LT              reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    LET             reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    GT              reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    GET             reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    DIFF            reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    AND             reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    OR              reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    RPAREN          reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    COMMA           reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    RBRACKET        reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76

  ! PLUS            [ reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .) ]
  ! MINUS           [ reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .) ]
  ! MULTIPLY        [ reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .) ]
  ! DIVIDE          [ reduce using rule 60 (expr_arithm -> expr_arithm PLUS expr_arithm .) ]


state 108

    (61) expr_arithm -> expr_arithm MINUS expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMI            reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    EQ              reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    LT              reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    LET             reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    GT              reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    GET             reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    DIFF            reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    AND             reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    OR              reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    RPAREN          reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    COMMA           reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    RBRACKET        reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76

  ! PLUS            [ reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .) ]
  ! MINUS           [ reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .) ]
  ! MULTIPLY        [ reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .) ]
  ! DIVIDE          [ reduce using rule 61 (expr_arithm -> expr_arithm MINUS expr_arithm .) ]


state 109

    (62) expr_arithm -> expr_arithm MULTIPLY expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMI            reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    EQ              reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    LT              reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    LET             reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    GT              reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    GET             reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    DIFF            reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    AND             reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    OR              reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    RPAREN          reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    COMMA           reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    RBRACKET        reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76

  ! PLUS            [ reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .) ]
  ! MINUS           [ reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .) ]
  ! MULTIPLY        [ reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .) ]
  ! DIVIDE          [ reduce using rule 62 (expr_arithm -> expr_arithm MULTIPLY expr_arithm .) ]


state 110

    (63) expr_arithm -> expr_arithm DIVIDE expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMI            reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    EQ              reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    LT              reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    LET             reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    GT              reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    GET             reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    DIFF            reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    AND             reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    OR              reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    RPAREN          reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    COMMA           reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    RBRACKET        reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76

  ! PLUS            [ reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .) ]
  ! MINUS           [ reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .) ]
  ! MULTIPLY        [ reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .) ]
  ! DIVIDE          [ reduce using rule 63 (expr_arithm -> expr_arithm DIVIDE expr_arithm .) ]


state 111

    (46) logic_list -> logic_list AND logic_list .
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 46 (logic_list -> logic_list AND logic_list .)
    RPAREN          reduce using rule 46 (logic_list -> logic_list AND logic_list .)
    COMMA           reduce using rule 46 (logic_list -> logic_list AND logic_list .)
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! AND             [ reduce using rule 46 (logic_list -> logic_list AND logic_list .) ]
  ! OR              [ reduce using rule 46 (logic_list -> logic_list AND logic_list .) ]


state 112

    (47) logic_list -> logic_list OR logic_list .
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 47 (logic_list -> logic_list OR logic_list .)
    RPAREN          reduce using rule 47 (logic_list -> logic_list OR logic_list .)
    COMMA           reduce using rule 47 (logic_list -> logic_list OR logic_list .)
    AND             shift and go to state 77
    OR              shift and go to state 78

  ! AND             [ reduce using rule 47 (logic_list -> logic_list OR logic_list .) ]
  ! OR              [ reduce using rule 47 (logic_list -> logic_list OR logic_list .) ]


state 113

    (59) expr_arithm -> LPAREN expr_arithm RPAREN .

    PLUS            reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    MINUS           reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    MULTIPLY        reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    DIVIDE          reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    SEMI            reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    EQ              reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    LT              reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    LET             reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    GT              reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    GET             reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    DIFF            reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    AND             reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    OR              reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    RPAREN          reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    COMMA           reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)
    RBRACKET        reduce using rule 59 (expr_arithm -> LPAREN expr_arithm RPAREN .)


state 114

    (45) logic_list -> LPAREN logic_list RPAREN .

    AND             reduce using rule 45 (logic_list -> LPAREN logic_list RPAREN .)
    OR              reduce using rule 45 (logic_list -> LPAREN logic_list RPAREN .)
    SEMI            reduce using rule 45 (logic_list -> LPAREN logic_list RPAREN .)
    RPAREN          reduce using rule 45 (logic_list -> LPAREN logic_list RPAREN .)
    COMMA           reduce using rule 45 (logic_list -> LPAREN logic_list RPAREN .)


state 115

    (49) expr_bool -> expr_bool EQ expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    OR              reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    SEMI            reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    RPAREN          reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    COMMA           reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    RBRACKET        reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]
  ! LT              [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]
  ! LET             [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]
  ! GT              [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]
  ! GET             [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]
  ! DIFF            [ reduce using rule 49 (expr_bool -> expr_bool EQ expr_bool .) ]


state 116

    (50) expr_bool -> expr_bool LT expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    OR              reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    SEMI            reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    RPAREN          reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    COMMA           reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    RBRACKET        reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]
  ! LT              [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]
  ! LET             [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]
  ! GT              [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]
  ! GET             [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]
  ! DIFF            [ reduce using rule 50 (expr_bool -> expr_bool LT expr_bool .) ]


state 117

    (51) expr_bool -> expr_bool LET expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    OR              reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    SEMI            reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    RPAREN          reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    COMMA           reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    RBRACKET        reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]
  ! LT              [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]
  ! LET             [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]
  ! GT              [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]
  ! GET             [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]
  ! DIFF            [ reduce using rule 51 (expr_bool -> expr_bool LET expr_bool .) ]


state 118

    (52) expr_bool -> expr_bool GT expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    OR              reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    SEMI            reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    RPAREN          reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    COMMA           reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    RBRACKET        reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]
  ! LT              [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]
  ! LET             [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]
  ! GT              [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]
  ! GET             [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]
  ! DIFF            [ reduce using rule 52 (expr_bool -> expr_bool GT expr_bool .) ]


state 119

    (53) expr_bool -> expr_bool GET expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    OR              reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    SEMI            reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    RPAREN          reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    COMMA           reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    RBRACKET        reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]
  ! LT              [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]
  ! LET             [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]
  ! GT              [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]
  ! GET             [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]
  ! DIFF            [ reduce using rule 53 (expr_bool -> expr_bool GET expr_bool .) ]


state 120

    (54) expr_bool -> expr_bool DIFF expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GET resolved as shift
  ! shift/reduce conflict for DIFF resolved as shift
    AND             reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    OR              reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    SEMI            reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    RPAREN          reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    COMMA           reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    RBRACKET        reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89

  ! EQ              [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]
  ! LT              [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]
  ! LET             [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]
  ! GT              [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]
  ! GET             [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]
  ! DIFF            [ reduce using rule 54 (expr_bool -> expr_bool DIFF expr_bool .) ]


state 121

    (73) expr_list -> LBRACKET expr_inside_list RBRACKET .

    SEMI            reduce using rule 73 (expr_list -> LBRACKET expr_inside_list RBRACKET .)


state 122

    (74) expr_inside_list -> expr_inside_list COMMA . expr_type
    (75) expr_inside_list -> expr_inside_list COMMA . expr_bool
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43
    ID              shift and go to state 68
    LPAREN          shift and go to state 56
    MINUS           shift and go to state 38

    expr_type                      shift and go to state 133
    expr_bool                      shift and go to state 134
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36
    function                       shift and go to state 65
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17

state 123

    (34) list -> list COMMA ID .
    (33) function -> ID . LPAREN list RPAREN
    (65) expr_arithm -> ID .
    (70) sent_index_list -> ID . LBRACKET ID RBRACKET
    (72) sent_index_list -> ID . LBRACKET INTEGER RBRACKET

  ! reduce/reduce conflict for RPAREN resolved using rule 34 (list -> list COMMA ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 34 (list -> list COMMA ID .)
    RPAREN          reduce using rule 34 (list -> list COMMA ID .)
    COMMA           reduce using rule 34 (list -> list COMMA ID .)
    LPAREN          shift and go to state 22
    PLUS            reduce using rule 65 (expr_arithm -> ID .)
    MINUS           reduce using rule 65 (expr_arithm -> ID .)
    MULTIPLY        reduce using rule 65 (expr_arithm -> ID .)
    DIVIDE          reduce using rule 65 (expr_arithm -> ID .)
    EQ              reduce using rule 65 (expr_arithm -> ID .)
    LT              reduce using rule 65 (expr_arithm -> ID .)
    LET             reduce using rule 65 (expr_arithm -> ID .)
    GT              reduce using rule 65 (expr_arithm -> ID .)
    GET             reduce using rule 65 (expr_arithm -> ID .)
    DIFF            reduce using rule 65 (expr_arithm -> ID .)
    AND             reduce using rule 65 (expr_arithm -> ID .)
    OR              reduce using rule 65 (expr_arithm -> ID .)
    LBRACKET        shift and go to state 23

  ! RPAREN          [ reduce using rule 65 (expr_arithm -> ID .) ]
  ! COMMA           [ reduce using rule 65 (expr_arithm -> ID .) ]


state 124

    (35) list -> list COMMA function .
    (66) expr_arithm -> function .
    (56) expr_bool -> function .

  ! reduce/reduce conflict for RPAREN resolved using rule 35 (list -> list COMMA function .)
  ! reduce/reduce conflict for COMMA resolved using rule 35 (list -> list COMMA function .)
  ! reduce/reduce conflict for EQ resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for LET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GT resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for GET resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for DIFF resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for AND resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for OR resolved using rule 56 (expr_bool -> function .)
  ! reduce/reduce conflict for RPAREN resolved using rule 35 (list -> list COMMA function .)
  ! reduce/reduce conflict for COMMA resolved using rule 35 (list -> list COMMA function .)
    RPAREN          reduce using rule 35 (list -> list COMMA function .)
    COMMA           reduce using rule 35 (list -> list COMMA function .)
    PLUS            reduce using rule 66 (expr_arithm -> function .)
    MINUS           reduce using rule 66 (expr_arithm -> function .)
    MULTIPLY        reduce using rule 66 (expr_arithm -> function .)
    DIVIDE          reduce using rule 66 (expr_arithm -> function .)
    EQ              reduce using rule 56 (expr_bool -> function .)
    LT              reduce using rule 56 (expr_bool -> function .)
    LET             reduce using rule 56 (expr_bool -> function .)
    GT              reduce using rule 56 (expr_bool -> function .)
    GET             reduce using rule 56 (expr_bool -> function .)
    DIFF            reduce using rule 56 (expr_bool -> function .)
    AND             reduce using rule 56 (expr_bool -> function .)
    OR              reduce using rule 56 (expr_bool -> function .)

  ! RPAREN          [ reduce using rule 66 (expr_arithm -> function .) ]
  ! COMMA           [ reduce using rule 66 (expr_arithm -> function .) ]
  ! EQ              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! LET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GT              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! GET             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! DIFF            [ reduce using rule 66 (expr_arithm -> function .) ]
  ! AND             [ reduce using rule 66 (expr_arithm -> function .) ]
  ! OR              [ reduce using rule 66 (expr_arithm -> function .) ]
  ! RPAREN          [ reduce using rule 56 (expr_bool -> function .) ]
  ! COMMA           [ reduce using rule 56 (expr_bool -> function .) ]


state 125

    (38) list -> list COMMA expr_type .
    (67) expr_arithm -> expr_type .
    (57) expr_bool -> expr_type .

  ! reduce/reduce conflict for RPAREN resolved using rule 38 (list -> list COMMA expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 38 (list -> list COMMA expr_type .)
  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for AND resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for OR resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RPAREN resolved using rule 38 (list -> list COMMA expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 38 (list -> list COMMA expr_type .)
    RPAREN          reduce using rule 38 (list -> list COMMA expr_type .)
    COMMA           reduce using rule 38 (list -> list COMMA expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    AND             reduce using rule 57 (expr_bool -> expr_type .)
    OR              reduce using rule 57 (expr_bool -> expr_type .)

  ! RPAREN          [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! COMMA           [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! AND             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! OR              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RPAREN          [ reduce using rule 57 (expr_bool -> expr_type .) ]
  ! COMMA           [ reduce using rule 57 (expr_bool -> expr_type .) ]


state 126

    (41) list -> list COMMA expr_arithm .
    (60) expr_arithm -> expr_arithm . PLUS expr_arithm
    (61) expr_arithm -> expr_arithm . MINUS expr_arithm
    (62) expr_arithm -> expr_arithm . MULTIPLY expr_arithm
    (63) expr_arithm -> expr_arithm . DIVIDE expr_arithm
    (58) expr_bool -> expr_arithm .

  ! reduce/reduce conflict for RPAREN resolved using rule 41 (list -> list COMMA expr_arithm .)
  ! reduce/reduce conflict for COMMA resolved using rule 41 (list -> list COMMA expr_arithm .)
    RPAREN          reduce using rule 41 (list -> list COMMA expr_arithm .)
    COMMA           reduce using rule 41 (list -> list COMMA expr_arithm .)
    PLUS            shift and go to state 73
    MINUS           shift and go to state 74
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    EQ              reduce using rule 58 (expr_bool -> expr_arithm .)
    LT              reduce using rule 58 (expr_bool -> expr_arithm .)
    LET             reduce using rule 58 (expr_bool -> expr_arithm .)
    GT              reduce using rule 58 (expr_bool -> expr_arithm .)
    GET             reduce using rule 58 (expr_bool -> expr_arithm .)
    DIFF            reduce using rule 58 (expr_bool -> expr_arithm .)
    AND             reduce using rule 58 (expr_bool -> expr_arithm .)
    OR              reduce using rule 58 (expr_bool -> expr_arithm .)

  ! RPAREN          [ reduce using rule 58 (expr_bool -> expr_arithm .) ]
  ! COMMA           [ reduce using rule 58 (expr_bool -> expr_arithm .) ]


state 127

    (42) list -> list COMMA logic_list .
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          reduce using rule 42 (list -> list COMMA logic_list .)
    COMMA           reduce using rule 42 (list -> list COMMA logic_list .)
    AND             shift and go to state 77
    OR              shift and go to state 78


state 128

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr . COMMA for_valid_iter RPAREN LBRACE code RBRACE

    COMMA           shift and go to state 135


state 129

    (13) for_statement -> FOR LPAREN ID IN ID . RPAREN LBRACE code RBRACE

    RPAREN          shift and go to state 136


state 130

    (20) if_statement -> IF LPAREN logic_list RPAREN LBRACE . code RBRACE
    (21) if_statement -> IF LPAREN logic_list RPAREN LBRACE . code RBRACE elif_sent
    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE . code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE . code RBRACE elif_sent ELSE LBRACE code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 137
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 131

    (26) while_statement -> WHILE LPAREN logic_list RPAREN LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 138
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 132

    (27) function_definition -> DEF ID LPAREN RPAREN LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 139
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 133

    (74) expr_inside_list -> expr_inside_list COMMA expr_type .
    (57) expr_bool -> expr_type .
    (67) expr_arithm -> expr_type .

  ! reduce/reduce conflict for RBRACKET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for EQ resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for LET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GT resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for GET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 57 (expr_bool -> expr_type .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (expr_bool -> expr_type .)
    EQ              reduce using rule 57 (expr_bool -> expr_type .)
    LT              reduce using rule 57 (expr_bool -> expr_type .)
    LET             reduce using rule 57 (expr_bool -> expr_type .)
    GT              reduce using rule 57 (expr_bool -> expr_type .)
    GET             reduce using rule 57 (expr_bool -> expr_type .)
    DIFF            reduce using rule 57 (expr_bool -> expr_type .)
    RBRACKET        reduce using rule 57 (expr_bool -> expr_type .)
    COMMA           reduce using rule 57 (expr_bool -> expr_type .)
    PLUS            reduce using rule 67 (expr_arithm -> expr_type .)
    MINUS           reduce using rule 67 (expr_arithm -> expr_type .)
    MULTIPLY        reduce using rule 67 (expr_arithm -> expr_type .)
    DIVIDE          reduce using rule 67 (expr_arithm -> expr_type .)

  ! RBRACKET        [ reduce using rule 74 (expr_inside_list -> expr_inside_list COMMA expr_type .) ]
  ! COMMA           [ reduce using rule 74 (expr_inside_list -> expr_inside_list COMMA expr_type .) ]
  ! EQ              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! LET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GT              [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! GET             [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! DIFF            [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! RBRACKET        [ reduce using rule 67 (expr_arithm -> expr_type .) ]
  ! COMMA           [ reduce using rule 67 (expr_arithm -> expr_type .) ]


state 134

    (75) expr_inside_list -> expr_inside_list COMMA expr_bool .
    (49) expr_bool -> expr_bool . EQ expr_bool
    (50) expr_bool -> expr_bool . LT expr_bool
    (51) expr_bool -> expr_bool . LET expr_bool
    (52) expr_bool -> expr_bool . GT expr_bool
    (53) expr_bool -> expr_bool . GET expr_bool
    (54) expr_bool -> expr_bool . DIFF expr_bool

    RBRACKET        reduce using rule 75 (expr_inside_list -> expr_inside_list COMMA expr_bool .)
    COMMA           reduce using rule 75 (expr_inside_list -> expr_inside_list COMMA expr_bool .)
    EQ              shift and go to state 84
    LT              shift and go to state 85
    LET             shift and go to state 86
    GT              shift and go to state 87
    GET             shift and go to state 88
    DIFF            shift and go to state 89


state 135

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA . for_valid_iter RPAREN LBRACE code RBRACE
    (16) for_valid_iter -> . PLUS
    (17) for_valid_iter -> . PLUSPLUS
    (18) for_valid_iter -> . MINUS
    (19) for_valid_iter -> . MINUSMINUS

    PLUS            shift and go to state 141
    PLUSPLUS        shift and go to state 142
    MINUS           shift and go to state 143
    MINUSMINUS      shift and go to state 144

    for_valid_iter                 shift and go to state 140

state 136

    (13) for_statement -> FOR LPAREN ID IN ID RPAREN . LBRACE code RBRACE

    LBRACE          shift and go to state 145


state 137

    (20) if_statement -> IF LPAREN logic_list RPAREN LBRACE code . RBRACE
    (21) if_statement -> IF LPAREN logic_list RPAREN LBRACE code . RBRACE elif_sent
    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code . RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code . RBRACE elif_sent ELSE LBRACE code RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 146
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 138

    (26) while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 147
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 139

    (27) function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .

    DEF             reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    FOR             reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    IF              reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    WHILE           reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    ID              reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    $end            reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)
    RBRACE          reduce using rule 27 (function_definition -> DEF ID LPAREN RPAREN LBRACE code RBRACE .)


state 140

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter . RPAREN LBRACE code RBRACE

    RPAREN          shift and go to state 148


state 141

    (16) for_valid_iter -> PLUS .

    RPAREN          reduce using rule 16 (for_valid_iter -> PLUS .)


state 142

    (17) for_valid_iter -> PLUSPLUS .

    RPAREN          reduce using rule 17 (for_valid_iter -> PLUSPLUS .)


state 143

    (18) for_valid_iter -> MINUS .

    RPAREN          reduce using rule 18 (for_valid_iter -> MINUS .)


state 144

    (19) for_valid_iter -> MINUSMINUS .

    RPAREN          reduce using rule 19 (for_valid_iter -> MINUSMINUS .)


state 145

    (13) for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 149
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 146

    (20) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .
    (21) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE . elif_sent
    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE . ELSE LBRACE code RBRACE
    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE . elif_sent ELSE LBRACE code RBRACE
    (24) elif_sent -> . ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (25) elif_sent -> . empty
    (86) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for DEF resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for FOR resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for IF resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for WHILE resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for ID resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for $end resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    DEF             reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    FOR             reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    IF              reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    WHILE           reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    ID              reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    $end            reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    RBRACE          reduce using rule 20 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE .)
    ELSE            shift and go to state 151
    ELIF            shift and go to state 152

  ! ELSE            [ reduce using rule 86 (empty -> .) ]
  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]
  ! $end            [ reduce using rule 86 (empty -> .) ]
  ! RBRACE          [ reduce using rule 86 (empty -> .) ]

    elif_sent                      shift and go to state 150
    empty                          shift and go to state 153

state 147

    (26) while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .

    DEF             reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    FOR             reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    IF              reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    WHILE           reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    ID              reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    $end            reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)
    RBRACE          reduce using rule 26 (while_statement -> WHILE LPAREN logic_list RPAREN LBRACE code RBRACE .)


state 148

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN . LBRACE code RBRACE

    LBRACE          shift and go to state 154


state 149

    (13) for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 155
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 150

    (21) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .
    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent . ELSE LBRACE code RBRACE

    DEF             reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    FOR             reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    IF              reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    WHILE           reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    ID              reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    $end            reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    RBRACE          reduce using rule 21 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    ELSE            shift and go to state 156


state 151

    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE . LBRACE code RBRACE

    LBRACE          shift and go to state 157


state 152

    (24) elif_sent -> ELIF . LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent

    LPAREN          shift and go to state 158


state 153

    (25) elif_sent -> empty .

    ELSE            reduce using rule 25 (elif_sent -> empty .)
    DEF             reduce using rule 25 (elif_sent -> empty .)
    FOR             reduce using rule 25 (elif_sent -> empty .)
    IF              reduce using rule 25 (elif_sent -> empty .)
    WHILE           reduce using rule 25 (elif_sent -> empty .)
    ID              reduce using rule 25 (elif_sent -> empty .)
    $end            reduce using rule 25 (elif_sent -> empty .)
    RBRACE          reduce using rule 25 (elif_sent -> empty .)


state 154

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 159
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 155

    (13) for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .

    DEF             reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    FOR             reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    IF              reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    WHILE           reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    ID              reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    $end            reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)
    RBRACE          reduce using rule 13 (for_statement -> FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE .)


state 156

    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE . LBRACE code RBRACE

    LBRACE          shift and go to state 160


state 157

    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 161
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 158

    (24) elif_sent -> ELIF LPAREN . logic_list RPAREN LBRACE code RBRACE elif_sent
    (45) logic_list -> . LPAREN logic_list RPAREN
    (46) logic_list -> . logic_list AND logic_list
    (47) logic_list -> . logic_list OR logic_list
    (48) logic_list -> . expr_bool
    (49) expr_bool -> . expr_bool EQ expr_bool
    (50) expr_bool -> . expr_bool LT expr_bool
    (51) expr_bool -> . expr_bool LET expr_bool
    (52) expr_bool -> . expr_bool GT expr_bool
    (53) expr_bool -> . expr_bool GET expr_bool
    (54) expr_bool -> . expr_bool DIFF expr_bool
    (55) expr_bool -> . NOT expr_bool
    (56) expr_bool -> . function
    (57) expr_bool -> . expr_type
    (58) expr_bool -> . expr_arithm
    (81) expr_bool -> . TRUE
    (82) expr_bool -> . FALSE
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (79) expr_type -> . expr_num
    (80) expr_type -> . expr_string
    (59) expr_arithm -> . LPAREN expr_arithm RPAREN
    (60) expr_arithm -> . expr_arithm PLUS expr_arithm
    (61) expr_arithm -> . expr_arithm MINUS expr_arithm
    (62) expr_arithm -> . expr_arithm MULTIPLY expr_arithm
    (63) expr_arithm -> . expr_arithm DIVIDE expr_arithm
    (64) expr_arithm -> . MINUS expr_arithm
    (65) expr_arithm -> . ID
    (66) expr_arithm -> . function
    (67) expr_arithm -> . expr_type
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET
    (83) expr_num -> . FLOAT
    (84) expr_num -> . INTEGER
    (85) expr_string -> . STRING

    LPAREN          shift and go to state 63
    NOT             shift and go to state 44
    TRUE            shift and go to state 45
    FALSE           shift and go to state 46
    ID              shift and go to state 68
    MINUS           shift and go to state 38
    FLOAT           shift and go to state 41
    INTEGER         shift and go to state 42
    STRING          shift and go to state 43

    logic_list                     shift and go to state 162
    expr_bool                      shift and go to state 39
    function                       shift and go to state 65
    expr_type                      shift and go to state 66
    expr_arithm                    shift and go to state 67
    sent_index_list                shift and go to state 17
    expr_num                       shift and go to state 35
    expr_string                    shift and go to state 36

state 159

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 163
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 160

    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE . code RBRACE
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 164
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 161

    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 165
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 162

    (24) elif_sent -> ELIF LPAREN logic_list . RPAREN LBRACE code RBRACE elif_sent
    (46) logic_list -> logic_list . AND logic_list
    (47) logic_list -> logic_list . OR logic_list

    RPAREN          shift and go to state 166
    AND             shift and go to state 77
    OR              shift and go to state 78


state 163

    (12) for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .

    DEF             reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    FOR             reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    IF              reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    WHILE           reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    ID              reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    $end            reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)
    RBRACE          reduce using rule 12 (for_statement -> FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE .)


state 164

    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code . RBRACE
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 167
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 165

    (22) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .

    DEF             reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    FOR             reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    IF              reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    WHILE           reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    ID              reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    $end            reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)
    RBRACE          reduce using rule 22 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE .)


state 166

    (24) elif_sent -> ELIF LPAREN logic_list RPAREN . LBRACE code RBRACE elif_sent

    LBRACE          shift and go to state 168


state 167

    (23) if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .

    DEF             reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    FOR             reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    IF              reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    WHILE           reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    ID              reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    $end            reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)
    RBRACE          reduce using rule 23 (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE .)


state 168

    (24) elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE . code RBRACE elif_sent
    (1) code -> . code sent
    (2) code -> . sent
    (3) code -> . empty
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (86) empty -> .
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RBRACE          reduce using rule 86 (empty -> .)
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

  ! DEF             [ reduce using rule 86 (empty -> .) ]
  ! FOR             [ reduce using rule 86 (empty -> .) ]
  ! IF              [ reduce using rule 86 (empty -> .) ]
  ! WHILE           [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    code                           shift and go to state 169
    sent                           shift and go to state 2
    empty                          shift and go to state 3
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 169

    (24) elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code . RBRACE elif_sent
    (1) code -> code . sent
    (4) sent -> . statement
    (5) sent -> . instruction SEMI
    (8) statement -> . function_definition
    (9) statement -> . for_statement
    (10) statement -> . if_statement
    (11) statement -> . while_statement
    (6) instruction -> . assign
    (7) instruction -> . function
    (27) function_definition -> . DEF ID LPAREN RPAREN LBRACE code RBRACE
    (12) for_statement -> . FOR LPAREN for_valid_expr COMMA for_valid_expr COMMA for_valid_iter RPAREN LBRACE code RBRACE
    (13) for_statement -> . FOR LPAREN ID IN ID RPAREN LBRACE code RBRACE
    (20) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE
    (21) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (22) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE ELSE LBRACE code RBRACE
    (23) if_statement -> . IF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent ELSE LBRACE code RBRACE
    (26) while_statement -> . WHILE LPAREN logic_list RPAREN LBRACE code RBRACE
    (28) assign -> . ID ASSIGN expr_type
    (29) assign -> . ID ASSIGN expr_arithm
    (30) assign -> . ID ASSIGN logic_list
    (31) assign -> . ID ASSIGN expr_list
    (32) assign -> . ID ASSIGN function
    (33) function -> . ID LPAREN list RPAREN
    (68) function -> . sent_index_list
    (69) sent_index_list -> . sent_index_list LBRACKET ID RBRACKET
    (70) sent_index_list -> . ID LBRACKET ID RBRACKET
    (71) sent_index_list -> . sent_index_list LBRACKET INTEGER RBRACKET
    (72) sent_index_list -> . ID LBRACKET INTEGER RBRACKET

    RBRACE          shift and go to state 170
    DEF             shift and go to state 12
    FOR             shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    ID              shift and go to state 13

    sent                           shift and go to state 18
    statement                      shift and go to state 4
    instruction                    shift and go to state 5
    function_definition            shift and go to state 6
    for_statement                  shift and go to state 7
    if_statement                   shift and go to state 8
    while_statement                shift and go to state 9
    assign                         shift and go to state 10
    function                       shift and go to state 11
    sent_index_list                shift and go to state 17

state 170

    (24) elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE . elif_sent
    (24) elif_sent -> . ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent
    (25) elif_sent -> . empty
    (86) empty -> .

    ELIF            shift and go to state 152
    ELSE            reduce using rule 86 (empty -> .)
    DEF             reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)
    RBRACE          reduce using rule 86 (empty -> .)

    elif_sent                      shift and go to state 171
    empty                          shift and go to state 153

state 171

    (24) elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .

    ELSE            reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    DEF             reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    FOR             reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    IF              reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    WHILE           reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    ID              reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    $end            reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)
    RBRACE          reduce using rule 24 (elif_sent -> ELIF LPAREN logic_list RPAREN LBRACE code RBRACE elif_sent .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DEF in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for EQ in state 94 resolved as shift
WARNING: shift/reduce conflict for LT in state 94 resolved as shift
WARNING: shift/reduce conflict for LET in state 94 resolved as shift
WARNING: shift/reduce conflict for GT in state 94 resolved as shift
WARNING: shift/reduce conflict for GET in state 94 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 94 resolved as shift
WARNING: shift/reduce conflict for DEF in state 106 resolved as shift
WARNING: shift/reduce conflict for FOR in state 106 resolved as shift
WARNING: shift/reduce conflict for IF in state 106 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 106 resolved as shift
WARNING: shift/reduce conflict for ID in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 108 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 108 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 111 resolved as shift
WARNING: shift/reduce conflict for OR in state 111 resolved as shift
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for LET in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for GET in state 115 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for LET in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for GET in state 116 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for LT in state 117 resolved as shift
WARNING: shift/reduce conflict for LET in state 117 resolved as shift
WARNING: shift/reduce conflict for GT in state 117 resolved as shift
WARNING: shift/reduce conflict for GET in state 117 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 117 resolved as shift
WARNING: shift/reduce conflict for EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for LT in state 118 resolved as shift
WARNING: shift/reduce conflict for LET in state 118 resolved as shift
WARNING: shift/reduce conflict for GT in state 118 resolved as shift
WARNING: shift/reduce conflict for GET in state 118 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 118 resolved as shift
WARNING: shift/reduce conflict for EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for LT in state 119 resolved as shift
WARNING: shift/reduce conflict for LET in state 119 resolved as shift
WARNING: shift/reduce conflict for GT in state 119 resolved as shift
WARNING: shift/reduce conflict for GET in state 119 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 119 resolved as shift
WARNING: shift/reduce conflict for EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for LT in state 120 resolved as shift
WARNING: shift/reduce conflict for LET in state 120 resolved as shift
WARNING: shift/reduce conflict for GT in state 120 resolved as shift
WARNING: shift/reduce conflict for GET in state 120 resolved as shift
WARNING: shift/reduce conflict for DIFF in state 120 resolved as shift
WARNING: shift/reduce conflict for DEF in state 130 resolved as shift
WARNING: shift/reduce conflict for FOR in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 130 resolved as shift
WARNING: shift/reduce conflict for ID in state 130 resolved as shift
WARNING: shift/reduce conflict for DEF in state 131 resolved as shift
WARNING: shift/reduce conflict for FOR in state 131 resolved as shift
WARNING: shift/reduce conflict for IF in state 131 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 131 resolved as shift
WARNING: shift/reduce conflict for ID in state 131 resolved as shift
WARNING: shift/reduce conflict for DEF in state 145 resolved as shift
WARNING: shift/reduce conflict for FOR in state 145 resolved as shift
WARNING: shift/reduce conflict for IF in state 145 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 146 resolved as shift
WARNING: shift/reduce conflict for DEF in state 154 resolved as shift
WARNING: shift/reduce conflict for FOR in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 154 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 154 resolved as shift
WARNING: shift/reduce conflict for ID in state 154 resolved as shift
WARNING: shift/reduce conflict for DEF in state 157 resolved as shift
WARNING: shift/reduce conflict for FOR in state 157 resolved as shift
WARNING: shift/reduce conflict for IF in state 157 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for DEF in state 160 resolved as shift
WARNING: shift/reduce conflict for FOR in state 160 resolved as shift
WARNING: shift/reduce conflict for IF in state 160 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 160 resolved as shift
WARNING: shift/reduce conflict for ID in state 160 resolved as shift
WARNING: shift/reduce conflict for DEF in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: reduce/reduce conflict in state 30 resolved using rule (assign -> ID ASSIGN expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 30
WARNING: reduce/reduce conflict in state 30 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 30
WARNING: reduce/reduce conflict in state 30 resolved using rule (assign -> ID ASSIGN expr_type)
WARNING: rejected rule (expr_bool -> expr_type) in state 30
WARNING: reduce/reduce conflict in state 31 resolved using rule (assign -> ID ASSIGN expr_arithm)
WARNING: rejected rule (expr_bool -> expr_arithm) in state 31
WARNING: reduce/reduce conflict in state 34 resolved using rule (assign -> ID ASSIGN function)
WARNING: rejected rule (expr_arithm -> function) in state 34
WARNING: reduce/reduce conflict in state 34 resolved using rule (expr_bool -> function)
WARNING: rejected rule (expr_arithm -> function) in state 34
WARNING: reduce/reduce conflict in state 34 resolved using rule (assign -> ID ASSIGN function)
WARNING: rejected rule (expr_bool -> function) in state 34
WARNING: reduce/reduce conflict in state 47 resolved using rule (list -> ID)
WARNING: rejected rule (expr_arithm -> ID) in state 47
WARNING: reduce/reduce conflict in state 49 resolved using rule (list -> function)
WARNING: rejected rule (expr_arithm -> function) in state 49
WARNING: reduce/reduce conflict in state 49 resolved using rule (expr_bool -> function)
WARNING: rejected rule (expr_arithm -> function) in state 49
WARNING: reduce/reduce conflict in state 49 resolved using rule (list -> function)
WARNING: rejected rule (expr_bool -> function) in state 49
WARNING: reduce/reduce conflict in state 50 resolved using rule (list -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 50
WARNING: reduce/reduce conflict in state 50 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 50
WARNING: reduce/reduce conflict in state 50 resolved using rule (list -> expr_type)
WARNING: rejected rule (expr_bool -> expr_type) in state 50
WARNING: reduce/reduce conflict in state 52 resolved using rule (list -> expr_arithm)
WARNING: rejected rule (expr_bool -> expr_arithm) in state 52
WARNING: reduce/reduce conflict in state 59 resolved using rule (for_valid_expr -> expr_num)
WARNING: rejected rule (expr_type -> expr_num) in state 59
WARNING: reduce/reduce conflict in state 65 resolved using rule (expr_bool -> function)
WARNING: rejected rule (expr_arithm -> function) in state 65
WARNING: reduce/reduce conflict in state 66 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 66
WARNING: reduce/reduce conflict in state 81 resolved using rule (expr_bool -> function)
WARNING: rejected rule (expr_arithm -> function) in state 81
WARNING: reduce/reduce conflict in state 82 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 82
WARNING: reduce/reduce conflict in state 91 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_inside_list -> expr_type) in state 91
WARNING: reduce/reduce conflict in state 91 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 91
WARNING: reduce/reduce conflict in state 123 resolved using rule (list -> list COMMA ID)
WARNING: rejected rule (expr_arithm -> ID) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (list -> list COMMA function)
WARNING: rejected rule (expr_arithm -> function) in state 124
WARNING: reduce/reduce conflict in state 124 resolved using rule (expr_bool -> function)
WARNING: rejected rule (expr_arithm -> function) in state 124
WARNING: reduce/reduce conflict in state 124 resolved using rule (list -> list COMMA function)
WARNING: rejected rule (expr_bool -> function) in state 124
WARNING: reduce/reduce conflict in state 125 resolved using rule (list -> list COMMA expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 125
WARNING: reduce/reduce conflict in state 125 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 125
WARNING: reduce/reduce conflict in state 125 resolved using rule (list -> list COMMA expr_type)
WARNING: rejected rule (expr_bool -> expr_type) in state 125
WARNING: reduce/reduce conflict in state 126 resolved using rule (list -> list COMMA expr_arithm)
WARNING: rejected rule (expr_bool -> expr_arithm) in state 126
WARNING: reduce/reduce conflict in state 133 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_inside_list -> expr_inside_list COMMA expr_type) in state 133
WARNING: reduce/reduce conflict in state 133 resolved using rule (expr_bool -> expr_type)
WARNING: rejected rule (expr_arithm -> expr_type) in state 133
WARNING: reduce/reduce conflict in state 146 resolved using rule (if_statement -> IF LPAREN logic_list RPAREN LBRACE code RBRACE)
WARNING: rejected rule (empty -> <empty>) in state 146
WARNING: Rule (expr_inside_list -> expr_type) is never reduced
WARNING: Rule (expr_inside_list -> expr_inside_list COMMA expr_type) is never reduced
